circuit:
IVs(Vin);
    Parallel(Pvin);
        R(Ra, 620);
        Series(SR);
            Series(Svin);
                R(P_treble_boost_plus, ?);
                Parallel(Ptreble_boost);
                    R(P_treble_boost_minus, ?);
                    Series(Streble_boost);
                        R(R_treble_boost_bw, ?);
                        Series(Streble_boost_1);
                            C(C_treble_boost, ?);
                            Custom(L_treble_boost, 0, prefix=nl_inductor::, rust_prefix=custom_nonlinear_inductor::, jai_prefix=, params=L_Params, vars=, state=L_State, updater=update_vars, incident=incident, reflected=reflected);
            Custom(R, 6, prefix=analog_eq_r::, rust_prefix=custom_analog_eq_rtype::, jai_prefix=, params=R_Params, vars=R_Vars, state=R_State, updater=update_vars, incident=incident, reflected=reflected);
                Series(Sb);
                    R(Rlc, 1k);
                    Parallel(Pb);
                        R(P_low_cut, ?);
                        C(C_low_cut, ?);
                R(P_treble_cut_plus, ?);
                Parallel(Ptreble_cut);
                    R(P_treble_cut_minus, ?);
                    Series(Streble_cut);
                        R(Rc, 75);
                        C(C_treble_cut, ?);
                Parallel(Pbass_boost);
                    R(P_low_boost, ?);
                    C(C_low_boost, ?);
                R(Rb, 10k);
                R(Rload, 1M);

inputs:
Vin

outputs:
V:Rload

meta:
include:"custom_analog_eq_rtype.h"
include:"custom_nonlinear_inductor.h"
load:"custom_analog_eq_rtype.jai"
load:"custom_nonlinear_inductor.jai"
use:crate::custom_analog_eq_rtype
use:crate::custom_nonlinear_inductor
namespace:analog_eq
